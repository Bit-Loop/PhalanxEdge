---
# TAILSCALE NETWORK DISCOVERY AND INVENTORY MANAGEMENT
# This playbook discovers and manages Tailscale network devices,
# maintaining a complete inventory with proper categorization.

# Import the bootstrap playbook first to ensure all dependencies are installed
- import_playbook: bootstrap-host.yml

# Main playbook for Tailscale device discovery and inventory management
- name: Discover Tailscale network and manage inventory
  hosts: localhost
  gather_facts: no
  strategy: free

  vars:
    # User and path configuration
    real_user: "{{ lookup('env', 'USER') }}"
    real_home: "/home/{{ real_user }}"
    
    # Directory structure
    output_dir: "{{ real_home }}/.tailscale/status"
    inventory_dir: "{{ real_home }}/.ansible/inventory"
    playbook_dir: "{{ real_home }}/.ansible/playbooks"
    
    # Files
    inventory_file: "{{ inventory_dir }}/tailscale.yml"
    hosts_file: "{{ inventory_dir }}/tailscale/hosts.yml"
    
    # Tailscale configuration
    tailscale_ip_prefix: "100."
    
    # File permissions
    inventory_file_mode: '0640'
    inventory_dir_mode: '0750'
    
    # Run control
    enable_alerting: false
    backup_inventory: true
    validate_inventory: true
    
  vars_files:
    - "{{ playbook_dir }}/vars/tailscale_secure.yml"

  pre_tasks:
    - name: Gather minimal facts
      setup:
        gather_subset: [min]

    - name: Create audit log
      blockinfile:
        path: "{{ output_dir }}/audit_log_{{ ansible_date_time.date }}.log"
        create: yes
        mode: '0640'
        block: |
          Tailscale inventory update initiated at {{ ansible_date_time.iso8601 }}
          User: {{ lookup('env', 'USER') }}
          Host: {{ inventory_hostname }}
      become: no

  tasks:
    #
    # BLOCK 1: ENVIRONMENT SETUP
    #
    - name: Setup environment
      block:
        - name: Ensure required directories exist
          file:
            path: "{{ item.path }}"
            state: directory
            mode: "{{ item.mode }}"
            owner: "{{ real_user }}"
            group: "{{ real_user }}"
          loop:
            - { path: "{{ output_dir }}", mode: '0750' }
            - { path: "{{ inventory_dir }}", mode: '0750' }
            - { path: "{{ inventory_dir }}/tailscale", mode: '0755' }
            - { path: "{{ playbook_dir }}", mode: '0750' }

        - name: Check for existing device files
          stat:
            path: "{{ output_dir }}/{{ item }}"
          register: previous_files
          loop:
            - active_devices.json
            - offline_devices.json
            
        - name: Load previous device state
          set_fact:
            previous_active_devices: "{{ lookup('file', output_dir + '/active_devices.json') | from_json | default([]) }}"
            previous_offline_devices: "{{ lookup('file', output_dir + '/offline_devices.json') | from_json | default([]) }}"
          when: previous_files.results[0].stat.exists | default(false) and 
                previous_files.results[1].stat.exists | default(false)
                
        - name: Initialize previous devices if files don't exist
          set_fact:
            previous_active_devices: []
            previous_offline_devices: []
          when: not (previous_files.results[0].stat.exists | default(false)) or
                not (previous_files.results[1].stat.exists | default(false))
      tags: [setup]

    #
    # BLOCK 2: TAILSCALE DATA COLLECTION
    #
    - name: Collect Tailscale device data
      block:
        - name: Get Tailscale status with enhanced exit node detection
          shell: |-
            set -o pipefail
            tailscale status | awk '
            BEGIN { 
              print "[";
              split("", ip_seen);
              split("", ip_index);
              count = 0;
            }
            /^{{ tailscale_ip_prefix | regex_escape }}/ {
              ip = $1;
              hostname = $2;
              machine_type = $4;
              state = "";
              for(i=5; i<=NF; i++) state = (state ? state " " : "") $i;
              
              # More robust exit node detection - look for both "exit node" and "offers exit node"
              is_exit_node = "false";
              if (tolower(state) ~ /exit node/ || tolower(state) ~ /offers exit node/) {
                is_exit_node = "true";
              }
              
              # Set online status explicitly based on presence of "offline" in state
              is_online = "true";
              if (tolower(state) ~ /offline/) {
                is_online = "false";
              }
              
              if (ip in ip_seen) {
                devices[ip_index[ip]] = sprintf("  {\"ip\": \"%s\", \"hostname\": \"%s\", \"machine_type\": \"%s\", \"state\": \"%s\", \"exit_node\": %s, \"online\": %s}", 
                  ip, hostname, machine_type, state, is_exit_node, is_online);
              } else {
                ip_seen[ip] = 1;
                ip_index[ip] = count;
                devices[count] = sprintf("  {\"ip\": \"%s\", \"hostname\": \"%s\", \"machine_type\": \"%s\", \"state\": \"%s\", \"exit_node\": %s, \"online\": %s}", 
                  ip, hostname, machine_type, state, is_exit_node, is_online);
                count++;
              }
            }
            END {
              for (i = 0; i < count; i++) {
                print devices[i] (i < count-1 ? "," : "");
              }
              print "]";
            }
            '
          args:
            executable: /bin/bash
          register: tailscale_json
          changed_when: false
          failed_when: tailscale_json.rc != 0 or (tailscale_json.stdout is not defined or tailscale_json.stdout == "")

        - name: Parse device data
          set_fact:
            all_devices: "{{ tailscale_json.stdout | from_json | default([]) }}"
          when: tailscale_json.stdout is defined and tailscale_json.stdout != ""

        - name: Validate parsed device data
          fail:
            msg: "Parsed Tailscale device data is not a list or is empty!"
          when: all_devices is not defined or not all_devices or all_devices is not iterable

        - name: Handle no devices case
          set_fact:
            all_devices: []
          when: tailscale_json.stdout is not defined or tailscale_json.stdout == ""
      tags: [collection]
      rescue:
        - name: Log data collection failure
          debug:
            msg: "Failed to collect Tailscale device data. Check if Tailscale is running and connected."
          
        - name: Use empty device list on failure
          set_fact:
            all_devices: []
          
        - name: Continue playbook execution
          meta: clear_host_errors

    #
    # BLOCK 3: DEVICE CATEGORIZATION
    #
    - name: Process and categorize devices
      block:
        - name: Separate devices by type (strictly exclusive groups)
          set_fact:
            # Exit nodes - highest priority
            exit_node_devices: >-
              {{ all_devices | selectattr('exit_node', 'equalto', true) | list }}
            # Offline devices (excluding exit nodes)
            offline_devices: >-
              {{ all_devices
                 | rejectattr('exit_node', 'equalto', true)
                 | selectattr('online', 'equalto', false) 
                 | list }}
            # Active devices (excluding exit nodes and offline devices)
            active_devices: >-
              {{ all_devices
                 | rejectattr('exit_node', 'equalto', true)
                 | selectattr('online', 'equalto', true)
                 | list }}

        - name: Identify state changes
          set_fact:
            newly_active_devices: "{{ active_devices | selectattr('ip', 'in', previous_offline_devices | map(attribute='ip')) | list }}"
            newly_offline_devices: "{{ offline_devices | selectattr('ip', 'in', previous_active_devices | map(attribute='ip')) | list }}"
            new_devices: "{{ all_devices | rejectattr('ip', 'in', (previous_active_devices + previous_offline_devices) | map(attribute='ip')) | list }}"
            removed_devices: "{{ (previous_active_devices + previous_offline_devices) | rejectattr('ip', 'in', all_devices | map(attribute='ip')) | list }}"

        - name: Write device data files
          copy:
            dest: "{{ output_dir }}/{{ item.filename }}"
            content: "{{ item.content | to_nice_json }}"
            mode: '0644'
          loop:
            - { filename: "active_devices.json", content: "{{ active_devices }}" }
            - { filename: "offline_devices.json", content: "{{ offline_devices }}" }
            - { filename: "exit_node_devices.json", content: "{{ exit_node_devices }}" }
            - { filename: "all_devices.json", content: "{{ all_devices }}" }
            - { filename: "state_changes.json", content: {
                "newly_active": "{{ newly_active_devices }}", 
                "newly_offline": "{{ newly_offline_devices }}", 
                "new_devices": "{{ new_devices }}", 
                "removed_devices": "{{ removed_devices }}"
              }}
          become: no
      tags: [categorization]

    #
    # BLOCK 4: IMPROVED INVENTORY MANAGEMENT
    #
    - name: Manage inventory
      block:
        - name: Check if inventory files exist
          stat:
            path: "{{ item }}"
          register: inventory_files_stat
          loop:
            - "{{ inventory_file }}"
            - "{{ hosts_file }}"

        - name: Create a dedicated backup directory
          file:
            path: "{{ real_home }}/.ansible/backups/{{ ansible_date_time.date }}"
            state: directory
            mode: "0750"

        - name: Backup existing inventory files
          copy:
            src: "{{ item.item }}"
            dest: "{{ real_home }}/.ansible/backups/{{ ansible_date_time.date }}/{{ item.item | basename }}"
            mode: "{{ inventory_file_mode }}"
          when: item.stat.exists and backup_inventory | bool
          loop: "{{ inventory_files_stat.results }}"

        # Instead of trying to merge with existing inventory,
        # we'll generate completely new files from our device data
        - name: Prepare strictly exclusive host dictionaries
          set_fact:
            exit_node_hosts_dict: "{{ dict(exit_node_devices | map(attribute='hostname') | zip(exit_node_devices)) }}"
            offline_hosts_dict: "{{ dict(offline_devices | map(attribute='hostname') | zip(offline_devices)) }}"
            active_hosts_dict: "{{ dict(active_devices | map(attribute='hostname') | zip(active_devices)) }}"

        - name: Add OS-based grouping
          set_fact:
            linux_hosts: "{{ dict(all_devices | selectattr('machine_type', 'equalto', 'linux') | map(attribute='hostname') | zip(all_devices | selectattr('machine_type', 'equalto', 'linux') | list)) }}"
            windows_hosts: "{{ dict(all_devices | selectattr('machine_type', 'equalto', 'windows') | map(attribute='hostname') | zip(all_devices | selectattr('machine_type', 'equalto', 'windows') | list)) }}"
            macos_hosts: "{{ dict(all_devices | selectattr('machine_type', 'equalto', 'macOS') | map(attribute='hostname') | zip(all_devices | selectattr('machine_type', 'equalto', 'macOS') | list)) }}"
            ios_hosts: "{{ dict(all_devices | selectattr('machine_type', 'equalto', 'iOS') | map(attribute='hostname') | zip(all_devices | selectattr('machine_type', 'equalto', 'iOS') | list)) }}"
            android_hosts: "{{ dict(all_devices | selectattr('machine_type', 'equalto', 'android') | map(attribute='hostname') | zip(all_devices | selectattr('machine_type', 'equalto', 'android') | list)) }}"
            freebsd_hosts: "{{ dict(all_devices | selectattr('machine_type', 'equalto', 'freebsd') | map(attribute='hostname') | zip(all_devices | selectattr('machine_type', 'equalto', 'freebsd') | list)) }}"
            other_hosts: "{{ dict(all_devices | rejectattr('machine_type', 'in', ['linux', 'windows', 'macOS', 'iOS', 'android', 'freebsd']) | map(attribute='hostname') | zip(all_devices | rejectattr('machine_type', 'in', ['linux', 'windows', 'macOS', 'iOS', 'android', 'freebsd']) | list)) }}"

        # Create a clean inventory structure from scratch
        - name: Create fresh inventory structure
          set_fact:
            new_inventory:
              all:
                children:
                  tailscale:
                    children:
                      active_devices:
                        hosts: "{{ active_hosts_dict | default({}) }}"
                      offline_devices:
                        hosts: "{{ offline_hosts_dict | default({}) }}"
                      exit_nodes:
                        hosts: "{{ exit_node_hosts_dict | default({}) }}"
                      os_types:
                        children:
                          linux:
                            hosts: "{{ linux_hosts | default({}) }}"
                          windows:
                            hosts: "{{ windows_hosts | default({}) }}"
                          macos:
                            hosts: "{{ macos_hosts | default({}) }}"
                          ios:
                            hosts: "{{ ios_hosts | default({}) }}"
                          android:
                            hosts: "{{ android_hosts | default({}) }}"
                          freebsd:
                            hosts: "{{ freebsd_hosts | default({}) }}"
                          other:
                            hosts: "{{ other_hosts | default({}) }}"

        # Process hosts to add ansible_host variable and clean up
        - name: Process hosts to add ansible_host variable
          block:
            - name: Process ansible_host for active devices
              set_fact:
                active_processed: "{{ {} | combine({item.key: {'ansible_host': item.value.ip} | combine(item.value)}) }}"
              loop: "{{ active_hosts_dict | dict2items }}"
              register: active_results
            
            - name: Process ansible_host for offline devices
              set_fact:
                offline_processed: "{{ {} | combine({item.key: {'ansible_host': item.value.ip} | combine(item.value)}) }}"
              loop: "{{ offline_hosts_dict | dict2items }}"
              register: offline_results
            
            - name: Process ansible_host for exit nodes
              set_fact:
                exit_node_processed: "{{ {} | combine({item.key: {'ansible_host': item.value.ip} | combine(item.value)}) }}"
              loop: "{{ exit_node_hosts_dict | dict2items }}"
              register: exit_node_results
            
            - name: Consolidate processed host data
              set_fact:
                processed_hosts:
                  active_devices: "{{ active_results.results | map(attribute='ansible_facts.active_processed') | list | combine }}"
                  offline_devices: "{{ offline_results.results | map(attribute='ansible_facts.offline_processed') | list | combine }}"
                  exit_nodes: "{{ exit_node_results.results | map(attribute='ansible_facts.exit_node_processed') | list | combine }}"
              when: active_results.results | length > 0 or offline_results.results | length > 0 or exit_node_results.results | length > 0

            - name: Create temporary dict with processed hosts
              set_fact:
                temp_dict:
                  all:
                    children:
                      tailscale:
                        children:
                          active_devices:
                            hosts: "{{ processed_hosts.active_devices | default({}) }}"
                          offline_devices:
                            hosts: "{{ processed_hosts.offline_devices | default({}) }}"
                          exit_nodes:
                            hosts: "{{ processed_hosts.exit_nodes | default({}) }}"

            - name: Update inventory with processed hosts
              set_fact:
                final_inventory: "{{ new_inventory | combine(temp_dict, recursive=true) }}"
          rescue:
            - name: Handle processing failure - set inventory
              set_fact:
                final_inventory: "{{ new_inventory }}"

            - name: Handle processing failure - notify
              debug:
                msg: "Warning: Failed to process ansible_host variables. Using base inventory."

        # CRITICAL: Acquire lock before writing to inventory file
        - name: Acquire lock for inventory write
          shell: |-
            exec 9>/tmp/tailscale_inventory.lock
            flock -x 9
            echo $$ > /tmp/tailscale_inventory.lock.pid
          args:
            executable: /bin/bash

        # Add before inventory file generation
        - name: Clean up any corrupted inventory files
          file:
            path: "{{ item }}"
            state: absent
          loop:
            - "{{ inventory_file }}"
            - "{{ hosts_file }}"
          when: (inventory_write is defined and inventory_write is failed) or 
                (hosts_write is defined and hosts_write is failed)

        # Write the YAML inventory file directly - using correct YAML inventory format
        - name: Write tailscale.yml inventory file
          copy:
            content: |
              ---
              # Tailscale inventory - Generated by Ansible
              # Last updated: {{ ansible_date_time.iso8601 }}
              all:
                children:
                  tailscale:
                    children:
                      active_devices:
                        hosts:
              {% for hostname, host in processed_hosts.active_devices.items() %}
                          {{ hostname }}:
                            ansible_host: {{ host.ip }}
                            machine_type: {{ host.machine_type }}
                            state: "{{ host.state }}"
                            exit_node: {{ host.exit_node }}
              {% endfor %}
                      offline_devices:
                        hosts:
              {% for hostname, host in processed_hosts.offline_devices.items() %}
                          {{ hostname }}:
                            ansible_host: {{ host.ip }}
                            machine_type: {{ host.machine_type }}
                            state: "{{ host.state }}"
                            exit_node: {{ host.exit_node }}
              {% endfor %}
                      exit_nodes:
                        hosts:
              {% for hostname, host in processed_hosts.exit_nodes.items() %}
                          {{ hostname }}:
                            ansible_host: {{ host.ip }}
                            machine_type: {{ host.machine_type }}
                            state: "{{ host.state }}"
                            exit_node: {{ host.exit_node }}
              {% endfor %}
                      linux:
                        hosts:
              {% for hostname, host in linux_hosts.items() if hostname not in processed_hosts.exit_nodes %}
                          {{ hostname }}:
              {% endfor %}
                      windows:
                        hosts:
              {% for hostname, host in windows_hosts.items() if hostname not in processed_hosts.exit_nodes %}
                          {{ hostname }}:
              {% endfor %}
                      macos:
                        hosts:
              {% for hostname, host in macos_hosts.items() if hostname not in processed_hosts.exit_nodes %}
                          {{ hostname }}:
              {% endfor %}
                      ios:
                        hosts:
              {% for hostname, host in ios_hosts.items() if hostname not in processed_hosts.exit_nodes %}
                          {{ hostname }}:
              {% endfor %}
                      android:
                        hosts:
              {% for hostname, host in android_hosts.items() if hostname not in processed_hosts.exit_nodes %}
                          {{ hostname }}:
              {% endfor %}
                      freebsd:
                        hosts:
              {% for hostname, host in freebsd_hosts.items() if hostname not in processed_hosts.exit_nodes %}
                          {{ hostname }}:
              {% endfor %}
                      other:
                        hosts:
              {% for hostname, host in other_hosts.items() if hostname not in processed_hosts.exit_nodes %}
                          {{ hostname }}:
              {% endfor %}
            dest: "{{ inventory_file }}"
            mode: "{{ inventory_file_mode }}"
          register: inventory_write

        # Create a valid INI-style hosts.yml file
        - name: Generate hosts.yml file
          copy:
            content: |
              # Tailscale Inventory - Generated by Ansible
              # Last updated: {{ ansible_date_time.iso8601 }}

              [tailscale:children]
              active_devices
              offline_devices
              exit_nodes
              linux
              windows
              macos
              ios
              android
              freebsd
              other

              [active_devices]
              {% for host in active_devices %}
              {{ host.hostname }} ansible_host={{ host.ip }} machine_type={{ host.machine_type }} state="{{ host.state }}"
              {% endfor %}

              [offline_devices]
              {% for host in offline_devices %}
              {{ host.hostname }} ansible_host={{ host.ip }} machine_type={{ host.machine_type }} state="{{ host.state }}"
              {% endfor %}

              [exit_nodes]
              {% for host in exit_node_devices %}
              {{ host.hostname }} ansible_host={{ host.ip }} machine_type={{ host.machine_type }} state="{{ host.state }}"
              {% endfor %}

              [linux]
              {% for host in all_devices if host.machine_type == 'linux' and not host.exit_node %}
              {{ host.hostname }}
              {% endfor %}

              [windows]
              {% for host in all_devices if host.machine_type == 'windows' and not host.exit_node %}
              {{ host.hostname }}
              {% endfor %}

              [macos]
              {% for host in all_devices if host.machine_type == 'macOS' and not host.exit_node %}
              {{ host.hostname }}
              {% endfor %}

              [ios]
              {% for host in all_devices if host.machine_type == 'iOS' and not host.exit_node %}
              {{ host.hostname }}
              {% endfor %}

              [android]
              {% for host in all_devices if host.machine_type == 'android' and not host.exit_node %}
              {{ host.hostname }}
              {% endfor %}

              [freebsd]
              {% for host in all_devices if host.machine_type == 'freebsd' and not host.exit_node %}
              {{ host.hostname }}
              {% endfor %}

              [other]
              {% for host in all_devices if host.machine_type not in ['linux', 'windows', 'macOS', 'iOS', 'android', 'freebsd'] and not host.exit_node %}
              {{ host.hostname }}
              {% endfor %}
            dest: "{{ hosts_file }}"
            mode: "0644"
          register: hosts_write

        # Validate that inventory file is usable by Ansible
        - name: Validate generated inventory
          shell: |-
            ansible-inventory --inventory "{{ inventory_file }}" --list
          register: inventory_test
          changed_when: false
          failed_when: false
          when: validate_inventory | bool

        - name: Display inventory validation result
          debug:
            msg: "Inventory validation {{ 'passed' if inventory_test.rc == 0 else 'failed' }}"
          when: validate_inventory | bool

        # Now inventory_test is defined, so you can use it
        - name: Clean up inventory files after failed validation
          file:
            path: "{{ item }}"
            state: absent
          loop:
            - "{{ inventory_file }}"
            - "{{ hosts_file }}"
          when: validate_inventory | bool and inventory_test is defined and inventory_test.rc != 0
          failed_when: false

        # Clean up inventory files after failed write
        - name: Clean up inventory files after failed write
          file:
            path: "{{ item }}"
            state: absent
          loop:
            - "{{ inventory_file }}"
            - "{{ hosts_file }}"
          when: (inventory_test.rc != 0)
          failed_when: false

        # Release the lock after writing
        - name: Release lock for inventory write
          file:
            path: /tmp/tailscale_inventory.lock
            state: absent
          check_mode: yes
          ignore_errors: yes

        # Handle inventory validation failure
        - name: Handle inventory validation failure
          block:
            - name: Restore backup inventory if available
              copy:
                src: "{{ item.item }}.bak.{{ ansible_date_time.epoch }}"
                dest: "{{ item.item }}"
                mode: "{{ inventory_file_mode }}"
              loop: "{{ inventory_files_stat.results }}"
              when: backup_inventory | bool
            
            - name: Alert on inventory validation failure
              debug:
                msg: "CRITICAL: Generated inventory is not valid. Check the inventory structure and format."
          when: validate_inventory | bool and inventory_test.rc != 0
      tags: [inventory]

    #
    # BLOCK 5: STATUS AND REPORTING
    #
    - name: Report status
      block:
        - name: Alert on state changes (if enabled)
          debug:
            msg:
              - "New devices: {{ new_devices | map(attribute='hostname') | list }}"
              - "Removed devices: {{ removed_devices | map(attribute='hostname') | list }}"
              - "Newly active: {{ newly_active_devices | map(attribute='hostname') | list }}"
              - "Newly offline: {{ newly_offline_devices | map(attribute='hostname') | list }}"
          when: (enable_alerting | bool) and 
                (new_devices or removed_devices or newly_active_devices or newly_offline_devices)

        - name: Show summary
          debug:
            msg:
              - "Active devices: {{ active_devices | length }}"
              - "Offline devices: {{ offline_devices | length }}"
              - "Exit node devices: {{ exit_node_devices | length }}"
              - "Total devices: {{ all_devices | length }}"
              - "Device files written to {{ output_dir }}/"
              - "Inventory updated at {{ inventory_file }}"
              - "Hosts file updated at {{ hosts_file }}"
      tags: [reporting]